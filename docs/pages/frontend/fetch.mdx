import { Steps } from 'nextra/components';
import { Callout } from 'nextra/components';
import { FileTree } from 'nextra/components';

# Fetch and Revalidate Data

You can fetching data for many ways. Befere you start you should read [GraphGL](/frontend/graphql) section and learn how to generate types form GraphQL.

## Server Side Rendering (SSR)

The best way and the most fastes way to fetching data. You can use it for fetching initial data for page.

<Steps>

### Create page

Create new page in `app` folder and define async component.

```tsx
export default async function Page() {}
```

### Function with fetcher

<Callout type="warning" emoji="⚠️">
  Due to SSR, you need to pass cookies to `fetcher` using `headers` option.
</Callout>

```ts
import { cookies } from 'next/headers';

import { fetcher } from '@/graphql/fetcher';
import {
  Forum_Forums__Show,
  type Forum_Forums__ShowQuery,
  type Forum_Forums__ShowQueryVariables
} from '@/graphql/hooks';
```

```tsx
const getData = async (variables: Forum_Forums__ShowQueryVariables) => {
  const { data } = await fetcher<Forum_Forums__ShowQuery, Forum_Forums__ShowQueryVariables>({
    query: Forum_Forums__Show,
    variables,
    headers: {
      Cookie: cookies().toString()
    }
  });

  return data;
};
```

### Run query

```tsx
export default async function Page() {
  const data = await getData();

  return <ForumsForumView data={data} />;
}
```

Inside view avoid using `"use client"` component. Of course you can use it if you really need.

</Steps>

## Query

Using [TanStack Query (React Query)](https://tanstack.com/query/latest/docs/react/overview). You can use it for fetching data after page load for example after click on button.

<Callout type="info" emoji="ℹ️">
  To save the best performerce your app you should use [React
  Lazy](https://react.dev/reference/react/lazy).
</Callout>

<Steps>

### Create hook

Inside `hooks/{module_name}` create new file with prefix `use`, for example `use-use-short-show-groups.ts`.

Your schema should be similar like this:

<FileTree>
  <FileTree.Folder name="hooks" defaultOpen>
    <FileTree.Folder name="module_name" defaultOpen>
      <FileTree.Folder name="groups" defaultOpen>
        <FileTree.File name="use-use-short-show-groups.ts" />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

```ts
export const useShortShowGroupsAdmin = () => {};
```

### useQuery

```ts
import { useQuery } from '@tanstack/react-query';

import { APIKeys } from '@/graphql/api-keys';
import { fetcher } from '@/graphql/fetcher';
import {
  Core_Groups__Admin__Show_Short,
  type Core_Groups__Admin__Show_ShortQuery,
  type Core_Groups__Admin__Show_ShortQueryVariables
} from '@/graphql/hooks';
```

```ts
export const useShortShowGroupsAdmin = () => {
  const api = useQuery({
    queryKey: [APIKeys.SHORT_GROUPS_MEMBERS],
    queryFn: async ({ signal }) => {
      const { data } = await fetcher<
        Core_Groups__Admin__Show_ShortQuery,
        Core_Groups__Admin__Show_ShortQueryVariables
      >({
        query: Core_Groups__Admin__Show_Short,
        variables: {
          first: 25
        },
        signal
      });

      return data;
    },
    refetchOnMount: true
  });

  return api;
};
```

- `signal` - is used for canceling request when component is unmounted
- `refetchOnMount` - is used for refetching data when component is mounted

<Callout type="info" emoji="ℹ️">
  `queryKey` have to be unique in your app. The best practise to name it is
  `module_name.method_name`.
</Callout>

### Example use

```tsx
export const ContentGroupsFiltersUsersMembersAdmin = () => {
  const { data, isFetching } = useShortShowGroupsAdmin();

  return (
    <div>
      {data.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}

      {isFetching && <div>Loading...</div>}
    </div>
  );
};
```

</Steps>

<Callout type="error" emoji="❌">
  Don't use prefetch for useQuery. If you need to use prefeth for useQuery that means you should use
  Server Side Rendering (SSR) fetching.
</Callout>

## Infinite Query

Using [TanStack Infinite Queries (React Query)](https://tanstack.com/query/latest/docs/react/guides/infinite-queries). You can using Infinite Query for fetching data for infinite scroll.

<Steps>

### Create hook

Inside `hooks/{module_name}` create new file with prefix `use`, for example `use-use-topics-list.ts`.

<FileTree>
  <FileTree.Folder name="hooks" defaultOpen>
    <FileTree.Folder name="module_name" defaultOpen>
      <FileTree.Folder name="topics" defaultOpen>
        <FileTree.File name="use-use-topics-list.ts" />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

### useInfiniteQuery

```ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { useParams } from 'next/navigation';

import { APIKeys } from '@/graphql/api-keys';
import { fetcher } from '@/graphql/fetcher';
import {
  Forum_Forums__Show_Item_More,
  type Forum_Forums__Show_Item_MoreQuery,
  type Forum_Forums__Show_Item_MoreQueryVariables,
  type ShowTopicsForumsObj
} from '@/graphql/hooks';
```

```ts
export const useTopicsList = () => {
  const { id } = useParams();

  const query = useInfiniteQuery({
    queryKey: [APIKeys.TOPICS_IN_FORUM, { id }],
    queryFn: async ({ pageParam, signal }) => {
      const { data } = await fetcher<
        Forum_Forums__Show_Item_MoreQuery,
        Forum_Forums__Show_Item_MoreQueryVariables
      >({
        query: Forum_Forums__Show_Item_More,
        variables: {
          ...pageParam,
          forumId: id
        },
        signal
      });

      return data;
    },
    initialPageParam: {
      first: 10
    },
    getNextPageParam: ({ forum_topics__show: { pageInfo } }) => {
      if (pageInfo.hasNextPage) {
        return {
          first: 10,
          cursor: pageInfo.endCursor
        };
      }
    }
  });

  return {
    ...query
  };
};
```

- `signal` - is used for canceling request when component is unmounted
- `pageParam` - is used for passing variables to query
- `initialPageParam` - is used for passing initial variables to query
- `getNextPageParam` - is used for passing variables to query when infinite scroll is triggered

### Parse map data

```ts
export const useTopicsList = () => {
  ...

  const data = useMemo(
    () => query.data.pages.flatMap(page => page.forum_topics__show.edges) ?? [],
    [query.data.pages]
  );

  return {
    ...query,
    data
  };
};
```

### Example use

```tsx
export const TopicsList = () => {
  const { data, isFetching, fetchNextPage, hasNextPage } = useTopicsList();

  return (
    <div>
      {data.map(item => (
        <div key={item.node.id}>{item.node.title}</div>
      ))}

      {isFetching && <div>Loading...</div>}

      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetching}>
          Load more
        </button>
      )}
    </div>
  );
};
```

### Prefetch data (SSR)

Compared to `useQuery` in `useInfiniteQuery` you can use prefetch.

Inside async component you can use [prefetchInfiniteQuery](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientfetchinfinitequery) function.

```tsx
import { cookies } from 'next/headers';
import { HydrationBoundary, dehydrate } from '@tanstack/react-query';

import { ForumsForumAdminView } from '@/admin/views/forum/forums/forums-forum-admin-view';
import getQueryClient from '@/functions/get-query-client';
import { fetcher } from '@/graphql/fetcher';
import { APIKeys } from '@/graphql/api-keys';
import {
  Forum_Forums__Admin__Show,
  type Forum_Forums__Admin__ShowQuery,
  type Forum_Forums__Admin__ShowQueryVariables
} from '@/graphql/hooks';
```

```tsx
export default async function Page() {
  const queryClient = getQueryClient();
  await queryClient.prefetchInfiniteQuery({
    queryKey: [APIKeys.FORUMS_ADMIN],
    queryFn: async ({ pageParam }) => {
      const { data } = await fetcher<
        Forum_Forums__Admin__ShowQuery,
        Forum_Forums__Admin__ShowQueryVariables
      >({
        query: Forum_Forums__Admin__Show,
        variables: pageParam,
        headers: {
          Cookie: cookies().toString()
        }
      });

      return data;
    },
    initialPageParam: {
      first: 10
    },
    getNextPageParam: ({ forum_forums__admin__show: { pageInfo } }) => {
      if (pageInfo.hasNextPage) {
        return {
          first: 10,
          cursor: pageInfo.endCursor
        };
      }
    },
    pages: 1
  });
  const dehydratedState = dehydrate(queryClient);

  return (
    <HydrationBoundary state={dehydratedState}>
      <ForumsForumAdminView />
    </HydrationBoundary>
  );
}
```

<Callout type="warning" emoji="⚠️">
  Remember to use the same `queryKey` as in `useInfiniteQuery`. Otherwise, the data will be fetched
  two times and SSR make no sense.
</Callout>

### Prefetch data (Client)

If you has already fetched data you can pass `initialData` to `useInfiniteQuery`.

```tsx
 const query = useInfiniteQuery({
    ...
    initialData: {
      pages: [{ forum_topics__show: initData }],
      pageParams: [{ first: 10 }]
    }
  });
```

</Steps>

## Mutation

NextJS allows you to use [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).

<Steps>

### Create action

Mutations should be placed in `hooks` folder next to client hook with `onSubmit`.

```ts
'use server';
```

```ts
export const mutationApi = async () => {};
```

### Use fetcher

Our `fetcher` should be wrapper with `try/catch` block to handle errors using client side.

```ts
'use server';

import { cookies } from 'next/headers';

import { fetcher } from '@/graphql/fetcher';
import {
  Forum_Topics__Actions__Lock_Toggle,
  type Forum_Topics__Actions__Lock_ToggleMutation,
  type Forum_Topics__Actions__Lock_ToggleMutationVariables
} from '@/graphql/hooks';
```

```ts
export const mutationApi = async (
  variables: Forum_Topics__Actions__Lock_ToggleMutationVariables
) => {
  try {
    const { data } = await fetcher<
      Forum_Topics__Actions__Lock_ToggleMutation,
      Forum_Topics__Actions__Lock_ToggleMutationVariables
    >({
      query: Forum_Topics__Actions__Lock_Toggle,
      variables,
      headers: {
        Cookie: cookies().toString()
      }
    });

    return { data };
  } catch (error) {
    return { error };
  }
};
```

<Callout type="warning" emoji="⚠️">
  Due to SSR, you need to pass cookies to `fetcher` using `headers` option.
</Callout>

### Example use

```ts
import { useTranslations } from 'next-intl';
import { toast } from 'sonner';

import { mutationApi } from './mutation-api';
```

```tsx
export const useLockToggleActionsTopic = ({ id }: { id: number }) => {
  const t = useTranslations('core');

  const onClick = async () => {
    const mutation = await mutationApi({ id });

    if (mutation.error) {
      toast.error(t('errors.title'), {
        description: t('errors.internal_server_error')
      });
    }
  };

  return { onClick };
};
```

- `toast` - is used for displaying toast messages. You can read more here in [Notifications Toast](/frontend/notifications/toast)

### Revalidate data (SSR)

NextJS allows you to use [Revalidating data](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#revalidating-data) in Server Actions.

This function only works when you're using Server Side Rendering (SSR) for fetching data.

```ts
'use server';

import { revalidatePath } from 'next/cache';
```

```tsx
export const mutationApi = async (
) => {
  try {
    ...

    revalidatePath('/topic/[id]', 'page');

    return { data };
  } catch (error) {
    return { error };
  }
};

```

### Revalidate data (Client)

Take a look at your mutation in Server Action. You have `data` variable from `fetcher` function and you return it. You can using this data to change data in cache using [queryClient.setQueryData](https://tanstack.com/query/latest/docs/react/reference/QueryClient#queryclientsetquerydata).

```ts
import { useQuery, useQueryClient, type InfiniteData } from '@tanstack/react-query';
import { APIKeys } from '@/graphql/api-keys';
import { type Forum_Topics__ShowQuery } from '@/graphql/hooks';
```

```ts
const queryClient = useQueryClient();

const onClick = async () => {
  const mutation = await mutationApi({ id });
  if (mutation.data) {
    queryClient.setQueryData<InfiniteData<Forum_Topics__ShowQuery>>([APIKeys.TOPICS], old => {
      if (!old) return old;

      return {
        ...old,
        pages: old.pages.map(page => ({
          ...page,
          forum_topics__show: {
            ...page.forum_topics__show,
            edges: mutation.data
          }
        }))
      };
    });

    return;
  }

  toast.error(t('errors.title'), {
    description: t('errors.internal_server_error')
  });
};
```

</Steps>

## Combine Methods

You don't need to use only one method. You can combine them.

For example:

- Fetching first page for infinite query using Server Side Rendering (SSR)
