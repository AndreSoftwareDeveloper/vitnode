import { Steps } from "nextra/components";
import { Callout } from "nextra/components";
import { Tabs } from "nextra/components";

# Internationalization (i18n)

VitNode uses not only native i18n from [next-intl](https://next-intl-docs.vercel.app/), but also dynamic translations from database. It gives your full control for your translations without restart your server.

## Static Translations

Static translations are translations that are stored in the code. It's useful when you want to have translations that are always the same.

<Steps>

### Create JSON file

**Only first time!**

Create a `JSON` file for your plugin _(if you don't have)_ in `frontend/locale/en/{plugin_code}.json`. For example `frontend/locale/en/blog.json`.

### Define translations

Define translations inside `{plugin_key}` object. For example in `blog` plugin:

✅ Correct:

```json
{
  "blog": {
    "title": "Blog",
    "actions": {
      "create": "Create post"
    }
  }
}
```

❌ Incorrect:

```json
{
  "title": "Blog",
  "actions": {
    "create": "Create post"
  }
}
```

❌ Incorrect:

```json
{
  "blog.title": "Blog",
  "blog.actions.create": "Create post"
}
```

❌ Incorrect:

```json
{
  "blog": {
    "title": "Blog"
  },
  "actions": {
    "create": "Create post"
  }
}
```

<Callout type="warning" emoji="⚠️">
  All your translations should be from your plugin key. You can use translations
  only from `core.sjon` and `admin.json` plugin.
</Callout>

### Use translations

<Tabs items={['Function Component', 'Async Function Component']}>
  <Tabs.Tab>

```tsx {1, 4, 6}
import { useTranslations } from "next-intl";

export const CategoriesBlogAdminView = () => {
  const t = useTranslations("blog.admin.categories");

  return <div>{t("title")}</div>;
};
```

  </Tabs.Tab>
  <Tabs.Tab>

```tsx {1, 3, 6}
import { getTranslations } from "next-intl/server";

export default async function Page() {
  const t = await getTranslations("blog");

  return <div>{t("title")}</div>;
}
```

  </Tabs.Tab>

</Tabs>

You can find more about [Rendering i18n messages from next-intl](https://next-intl-docs.vercel.app/docs/usage/messages) in their documentation.

</Steps>

## Dynamic Translations (Backend)

Dynamic translations are translations that are stored in the database. It's useful when you want to change translations without restarting the server.

As an example we will create a simple `core_nav` with translations.

<Steps>

### Create database schema

Create a schema `core_nav` in `database` folder.

```ts
export const core_nav = pgTable("core_nav", {
  id: serial("id").primaryKey(),
  href: varchar("href", { length: 255 }).notNull(),
  external: boolean("external").notNull().default(false),
  position: integer("position").notNull().default(0)
});
```

### Translation table

Create a schema `core_nav_name` in the same file for translation table.
The translation table must have:

- `language_code` with `varchar` type,
- `value` with `varchar` type _(You can set `length` option)_,
- any fields for relation with main table (in our case `nav_id`)

```ts
import { relations } from "drizzle-orm";
import { index, pgTable, serial, varchar } from "drizzle-orm/pg-core";

export const core_nav_name = pgTable(
  "core_nav_name",
  {
    id: serial("id").primaryKey(),
    nav_id: serial("nav_id")
      .notNull()
      .references(() => core_nav.id, {
        onDelete: "cascade"
      }),
    language_code: varchar("language_code")
      .notNull()
      .references(() => core_languages.code, {
        onDelete: "cascade"
      }),
    value: varchar("value", { length: 50 }).notNull()
  },
  table => ({
    nav_id_idx: index("core_nav_name_nav_id_idx").on(table.nav_id),
    language_code_idx: index("core_nav_name_language_code_idx").on(
      table.language_code
    )
  })
);
```

Remember to set `onDelete: 'cascade'` action into references and set `indexes` for best performerce. We want to delete translation when we delete main table.

## Relation

Add relation to main table.

```ts
export const core_nav_relations = relations(core_nav, ({ many }) => ({
  name: many(core_nav_name)
}));
```

You can read more about [relations using Drizzle here](https://orm.drizzle.team/docs/rqb).

### Input field mutation (Args)

For your mutation we're created for you a new type `TextLanguageInput`.

```ts {5-9, 13-17}
import { ArgsType, Field } from "@nestjs/graphql";
import { IsArray } from "class-validator";
import { Transform } from "class-transformer";

import {
  IsTextLanguageInput,
  TextLanguageInput,
  TransformTextLanguageInput
} from "@/types/database/text-language.type";

@ArgsType()
export class CreateAdminNavArgs {
  @IsArray()
  @IsTextLanguageInput()
  @Transform(TransformTextLanguageInput)
  @Field(() => [TextLanguageInput])
  name: TextLanguageInput[];
}
```

If you want to change this field to `required`, you have to add some decorators form `class-validator` like `ArrayMinSize` and `ValidateNested`.

```ts {2, 14-15}
import { ArgsType, Field } from "@nestjs/graphql";
import { ArrayMinSize, IsArray, ValidateNested } from "class-validator";
import { Transform } from "class-transformer";

import {
  IsTextLanguageInput,
  TextLanguageInput,
  TransformTextLanguageInput
} from "@/types/database/text-language.type";

@ArgsType()
export class CreateAdminNavArgs {
  @IsArray()
  @ValidateNested({ each: true })
  @ArrayMinSize(1)
  @IsTextLanguageInput()
  @Transform(TransformTextLanguageInput)
  @Field(() => [TextLanguageInput])
  name: TextLanguageInput[];
}
```

### Object field mutation (Obj)

For your mutation we're created for you a new type `TextLanguage`.

```ts {3, 7-8}
import { Field, ObjectType } from "@nestjs/graphql";

import { TextLanguage } from "@/types/database/text-language.type";

@ObjectType()
class ShowCoreNavItem {
  @Field(() => [TextLanguage])
  name: TextLanguage[];
}
```

## Create Mutation

Now let's create a mutation for adding new record to database with translations.

### Create record

Create a record in main table and get the id.

```ts
const nav = await this.databaseService.db
  .insert(core_nav)
  .values({
    href,
    external
  })
  .returning();

const id = nav[0].id;
```

### Create translations

Create translations for each language.

```ts
const namesNav = await this.databaseService.db
  .insert(core_nav_name)
  .values(
    name.map(n => ({
      nav_id: id,
      language_code: n.language_code,
      value: n.value
    }))
  )
  .returning();
```

But if you have empty array of translations, you have to handle it. You can't create empty translation.
We want `description` to be optional, so we have create an empty array if it's not passed.

```ts
const descriptionNav =
  description.length > 0
    ? await this.databaseService.db
        .insert(core_nav_description)
        .values(
          description.map(n => ({
            nav_id: id,
            language_code: n.language_code,
            value: n.value
          }))
        )
        .returning()
    : [];
```

## Update Mutation

In this case update data is a bit different.

You have to check if the translation:

- exists, update it,
- doesn't exist, create it,
- exists, but the value is empty or not passed, delete it.

It may sound complicated, but it's not. We will show you how to do it.

<Callout type="warning" emoji="⚠️">
  Remember to always check if redord exists before you update it. If it doesn't
  exist, you have to throw an error.
</Callout>

### Get all translations

```ts
const items = await this.databaseService.db.query.core_nav_name.findMany({
  where: (table, { eq }) => eq(table.nav_id, id)
});
```

### Update data

```ts
const update = await Promise.all(
  languageItemsArrayFromArgs.map(async item => {
    const itemExist = items.find(el => el.language_code === item.language_code);

    if (itemExist) {
      // If value is empty, do nothing
      if (!itemExist.value.trim()) return;

      const update = await this.databaseService.db
        .update(core_nav_name)
        .set({ ...item, nav_id: id })
        .where(eq(core_nav_name.id, itemExist.id))
        .returning();

      return update[0];
    }

    const insert = await this.databaseService.db
      .insert(core_nav_name)
      .values({ ...item, nav_id: id })
      .returning();

    return insert[0];
  })
);
```

### Delete remaining translations

```ts
Promise.all(
  items.map(async item => {
    const exist = update.find(name => name.id === item.id);
    if (exist) return;

    await this.databaseService.db
      .delete(core_nav_name)
      .where(eq(core_nav_name.id, item.id));
  })
);
```

## Delete Mutation

If you add `onDelete: Cascade` action to relation, you don't have to do anything. When you delete main record, all translations will be deleted.

</Steps>

## Dynamic Translations (Frontend)

Each dynamic translations are stored in database like this:

```ts
[
  {
    language_code: "en",
    value: "Hello world"
  },
  {
    language_code: "pl",
    value: "Witaj świecie"
  }
];
```

### Display text

To display text you can use `useTextLang` hook.

```tsx
import { useTextLang } from "@/hooks/core/use-text-lang";

const TestComponent = () => {
  const { convertText } = useTextLang();

  return <div>{convertText(value)}</div>;
};
```

`value` is `TextLanguage[]` interface form `GraphQL backend`.

### Form

Create form with translations is very similar to normal [Forms](/themes/forms).

<Steps>

### Define schema

```ts
import * as z from "zod";

import { zodInput } from "@/functions/zod";

const formSchema = z.object({
  name: zodInput.languageInput
});
```

Or you can set `maxLength` for each translation:

```ts
const formSchema = z.object({
  content: zodInput.languageInput
    .min(1, {
      message: t("errors.required")
    })
    .refine(value => value.every(item => item.value.length <= 100), {
      message: t("errors.max_length", { length: 100 })
    })
});
```

We're using `zodInput.languageInput` instead of `z.string` to add more functions to validate translations.

### Set initial values

```ts {7}
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";

const form = useForm<z.infer<typeof formSchema>>({
  resolver: zodResolver(formSchema),
  defaultValues: {
    name: []
  }
});
```

### Choose input

<Tabs items={['Text Input', 'Editor']}>
  <Tabs.Tab>

```tsx {1, 14}
import { TextLanguageInput } from "@/components/text-language-input";

const SimpleForm = () => {
  return (
    <>
      ...
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormItem>
            <FormLabel>{t("name.label")}</FormLabel>
            <FormControl>
              <TextLanguageInput {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
      ...
    </>
  );
};
```

  </Tabs.Tab>
  <Tabs.Tab>

```tsx {1, 14}
import { Editor } from "@/components/editor/editor";

const SimpleForm = () => {
  return (
    <>
      ...
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormItem>
            <FormLabel>{t("name.label")}</FormLabel>
            <FormControl>
              <Editor id="create_name" {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />
      ...
    </>
  );
};
```

  </Tabs.Tab>
</Tabs>

### Submit form

Now submit form like normal form.

</Steps>
