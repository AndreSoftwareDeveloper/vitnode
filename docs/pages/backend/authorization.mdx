# Authorization

In VitNode we're implementing a custom authorization system, which gives us more flexibility and control over the authorization process. Our system use [Guards](https://docs.nestjs.com/guards) from NestJS to protect routes.

## Portected route

To protect a route, you need to add the `@UseGuards(AuthGuards)` decorator to the route handler. This will make sure that the user is authenticated before accessing the route.

Here is an example for resolver:

```typescript
  import { AuthGuards } from '@/utils/guards/auth.guards';

  @Query(() => ShowCoreMembersObj)
  @UseGuards(AuthGuards)
  async show_core_members(@Args() args: ShowCoreMembersArgs): Promise<ShowCoreMembersObj> {
    return await this.service.show(args);
  }
```

Whan you are using `AuthGuards` you can access to the current user in the resolver by using the `@CurrentUser()` decorator.

```typescript
  import { User, CurrentUser } from '@/utils/decorators/user.decorators';

  @Query(() => ShowCoreMembersObj)
  @UseGuards(AuthGuards)
  async show_core_members(@Args() args: ShowCoreMembersArgs, @CurrentUser() user: User): Promise<ShowCoreMembersObj> {
    return await this.service.show(args);
  }
```

## Current user withouth guards

If you need to access the current user in a route that is not protected by `AuthGuards`, you can use the `@CurrentUser()` decorator.

```typescript
  import { User, CurrentUser } from '@/utils/decorators/user.decorators';

  @Query(() => ShowCoreMembersObj)
  async show_core_members(@Args() args: ShowCoreMembersArgs, @CurrentUser() user: User): Promise<ShowCoreMembersObj> {
    return await this.service.show(args);
  }
```
